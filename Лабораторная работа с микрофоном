// Подключаем библиотеку для FFT анализа
#include <arduinoFFT.h>
// Подключаем библиотеку для работы с I2C
#include <Wire.h>
// Подключаем библиотеку для управления LCD дисплеем
#include <LiquidCrystal_I2C.h>

// Пин A0 для подключения микрофона
#define MIC_PIN A0
// Адрес дисплея по шине I2C 
#define LCD_ADDR 0x27
// Количество символов в строке дисплея
#define LCD_COLS 16
// Количество строк на дисплее
#define LCD_ROWS 2

// Количество отсчетов для FFT 
#define FFT_SAMPLES 128
// Частота дискретизации в Герцах (макс. частота сигнала будет Fs/2 = 2000 Гц)
#define SAMPLING_FREQ 4000

// Вычисляем количество полос спектра (всегда половина от размера FFT)
#define FFT_BANDS (FFT_SAMPLES / 2)
// Вычисляем общее количество визуальных столбиков (16 колонок * 2 строки)
#define DISPLAY_BARS (LCD_COLS * LCD_ROWS)
// Вычисляем сколько полос FFT объединяется в один визуальный столбик
#define GROUP_SIZE (FFT_BANDS / DISPLAY_BARS)

// Создаем объект FFT с типом данных float (экономит память на Arduino Uno)
ArduinoFFT<float> FFT = ArduinoFFT<float>();
// Создаем объект дисплея с указанием адреса и размера
LiquidCrystal_I2C lcd(LCD_ADDR, LCD_COLS, LCD_ROWS);

// Массив для действительной части сигнала (входные данные и результат FFT)
float vReal[FFT_SAMPLES];
// Массив для мнимой части сигнала (заполняется нулями для реального сигнала)
float vImag[FFT_SAMPLES];
// Массив для хранения текущих значений высоты столбиков (0-7 уровней)
uint8_t barValues[DISPLAY_BARS];
// Массив для эффекта "задержки пика" (чтобы пики красиво опускались)
uint8_t peakHold[DISPLAY_BARS];

// Массив с графикой для 8 пользовательских символов 
byte levelChars[8][8] = {
  {0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b11111}, // Символ 0: 1/8 заполнения
  {0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b11111, 0b11111}, // Символ 1: 2/8 заполнения
  {0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b11111, 0b11111, 0b11111}, // Символ 2: 3/8 заполнения
  {0b00000, 0b00000, 0b00000, 0b00000, 0b11111, 0b11111, 0b11111, 0b11111}, // Символ 3: 4/8 заполнения
  {0b00000, 0b00000, 0b00000, 0b11111, 0b11111, 0b11111, 0b11111, 0b11111}, // Символ 4: 5/8 заполнения
  {0b00000, 0b00000, 0b11111, 0b11111, 0b11111, 0b11111, 0b11111, 0b11111}, // Символ 5: 6/8 заполнения
  {0b00000, 0b11111, 0b11111, 0b11111, 0b11111, 0b11111, 0b11111, 0b11111}, // Символ 6: 7/8 заполнения
  {0b11111, 0b11111, 0b11111, 0b11111, 0b11111, 0b11111, 0b11111, 0b11111}  // Символ 7: 8/8 (полный)
};

void setup() {
  // Инициализация последовательного порта для отладки
  Serial.begin(115200);
  
  // Запуск дисплея
  lcd.init();
  // Включение подсветки дисплея
  lcd.backlight();
  // Очистка экрана
  lcd.clear();
  // Установка курсора в начало (колонка 0, строка 0)
  lcd.setCursor(0, 0);
  // Вывод заголовка
  lcd.print("FFT Spectrum");
  // Установка курсора на вторую строку
  lcd.setCursor(0, 1);
  // Вывод сообщения о загрузке
  lcd.print("Loading...");
  
  // Цикл загрузки 8 пользовательских символов в память дисплея
  for (int i = 0; i < 8; i++) {
    // Запись символа i по коду i
    lcd.createChar(i, levelChars[i]);
  }
  
  // Пауза 1.5 секунды, чтобы прочитать приветствие
  delay(1500);
  // Очистка экрана перед началом работы
  lcd.clear();
  
  // Цикл инициализации массивов отображения
  for (int i = 0; i < DISPLAY_BARS; i++) {
    // Сброс текущего значения высоты столбика
    barValues[i] = 0;
    // Сброс значения пика
    peakHold[i] = 0;
  }
}

void loop() {
  // Цикл сбора 128 отсчетов сигнала
  for (int i = 0; i < FFT_SAMPLES; i++) {
    // Чтение значения с микрофона (0-1023) и запись в массив действительных чисел
    vReal[i] = analogRead(MIC_PIN);
    // Обнуление мнимой части (для реального аудиосигнала она всегда 0)
    vImag[i] = 0;
    // Запоминание текущего времени в микросекундах
    unsigned long startMicros = micros();
    // Цикл точного ожидания нужного интервала времени для равномерной дискретизации
    while ((micros() - startMicros) < (1000000 / SAMPLING_FREQ)) {
      // Пустая операция (ждем, пока не наступит время следующего отсчета)
      asm volatile("nop");
    }
  }
  // Применение окна Ханна для уменьшения искажений спектра
  FFT.windowing(vReal, FFT_SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD);
  // Выполнение прямого быстрого преобразования Фурье
  FFT.compute(vReal, vImag, FFT_SAMPLES, FFT_FORWARD);
  // Вычисление амплитуды (модуля комплексного числа) для каждой частоты
  FFT.complexToMagnitude(vReal, vImag, FFT_SAMPLES);
  // Цикл по всем 32 визуальным столбикам
  for (int bar = 0; bar < DISPLAY_BARS; bar++) {
    // Переменная для суммы амплитуд
    float sum = 0;
    
    // Внутренний цикл: объединяем несколько полос FFT в один визуальный бар
    for (int j = 0; j < GROUP_SIZE; j++) {
      // Вычисление индекса полосы в массиве FFT
      int fftIndex = bar * GROUP_SIZE + j;
      // Проверка, чтобы не выйти за границы массива
      if (fftIndex < FFT_BANDS) {
        // Добавление амплитуды к сумме
        sum += vReal[fftIndex];
      }
    }
    // Вычисление среднего значения амплитуды для этого бара
    float avg = sum / GROUP_SIZE;
    
    // Преобразование амплитуды в номер символа (0-7) с ограничением диапазона
    uint8_t level = (uint8_t)constrain(map(avg, 0, 200, 0, 8), 0, 7);
    
    // Логика плавного изменения высоты (чтобы столбики не дергались)
    if (level > barValues[bar]) {
      // Если сигнал стал громче — мгновенно поднимаем столбик
      barValues[bar] = level;
    } else {
      // Если сигнал тише — опускаем столбик плавно (на 1 шаг за цикл)
      barValues[bar] = max(level, barValues[bar] - 1);
    }
    
    // Логика "удержания пика" (маленькая задержка перед сбросом максимума)
    if (level > peakHold[bar]) {
      // Запоминаем новый пик
      peakHold[bar] = level;
    } else if (peakHold[bar] > 0) {
      // Постепенно уменьшаем значение пика
      peakHold[bar]--;
    }
  }
  
  // Вызов функции отрисовки спектра
  drawSpectrum();
  
  // Небольшая пауза для стабильности работы и визуального восприятия
  delay(20);
}

// Функция отрисовки спектра на LCD
void drawSpectrum() {
  // === ОТРИСОВКА ВЕРХНЕЙ СТРОКИ (бары 0-15) ===
  
  // Установка курсора в начало первой строки
  lcd.setCursor(0, 0);
  // Цикл по 16 колонкам верхней строки
  for (int i = 0; i < LCD_COLS; i++) {
    // Получение текущего уровня для этого бара
    uint8_t level = barValues[i];
    
    // Если активен "пик" и текущий уровень меньше максимума
    if (peakHold[i] == 7 && level < 7) {
      // Рисуем полный блок (символ 7) для индикации недавнего пика
      lcd.write(7);
    } else {
      // Иначе рисуем обычный символ уровня (0-7)
      lcd.write(level);
    }
  }
  
  // Установка курсора в начало второй строки
  lcd.setCursor(0, 1);
  // Цикл по 16 колонкам нижней строки
  for (int i = 0; i < LCD_COLS; i++) {
    // Получение уровня для бара (сдвиг индекса на 16, так как это вторая строка)
    uint8_t level = barValues[i + LCD_COLS];
    
    // Аналогичная проверка на пик
    if (peakHold[i + LCD_COLS] == 7 && level < 7) {
      lcd.write(7);
    } else {
      lcd.write(level);
    }
  }
}
```
